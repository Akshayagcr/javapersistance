
JPA = Object relational mapping specification
Hibernate/Eclipse link = JPA implementations

Two level of caching
First level : Write behind optimization (By default behaviour)
                Bound to current thread. Cached entity cannot be shared by multiple threads. *** It is Session scoped
Second level : Need to activate (@Cachable)
                Used by multiple concurrent threads. *** It is SessionFactory scoped

Associations
    oneToOne
    manyToOne
    manyToMany

Fetch type
    Eager
    Lazy




JPA
    First level cache = persistence context represented by EntityManager
Hibernate
    First level cache = persistence context represented by Session interface (Extends EntityManager)


Entity manager acts as transactional write behind cache. i.e. every method call on entityManager does not synchronizes state
with DB, only on flush method call changes are synchronize


Internally hibernate uses below map to store entities

Map<EntityUniqueKey, Object> entitiesByUniqueKey = new HashMap<>(INIT_COLL_SIZE);
EntityUniqueKey represents a row in DB = entity name + unique key

When we call find(entityClass, primaryKey) hibernate first check in first level cache then in second level cache
and if entity is not present in second level cache it fetches from DB.

Hibernate converts the resultSet of fetched result into object[] array called as loaded entity state (Initial state)
it is store alongside with entity in persistence context

When a flush operation happens dirty check mechanism compares the entity with loaded entity state to figure out the changes to determine the final 
SQL update query.


Entity state
    Transient   : Entity is not in persistence context as well as not in DB
    Managed     : Entity is present in persistence context and all updates will be synchronized with DB
    Removed     : If we call remove on persistence context for an entity 
    Detached    : if persistence context is closed or we explicitly detached it. Changes will not be synchronized

JPA methods working :
    persist : To move an entity from transient to managed we used persist method. which in all case triggers primary key generation SQL query
                as we need unique identifier to store it in persistence contest. and at later time during flush insert statements will be executed in bulk. exception is for
                an entity with id generation strategy IDENTITY as without insert the id will not be generated.
    merge   :  To attach detached entities back to persistence context we use merge method. In this case first a SELECT query will be executed to get the managed entity
                then the fields in detached entities are copied and then dirty checking mechanism will trigger the UPDATE statements.



***********************************************************************************

JPA : specification for object relational mapping and persistence layer

Hibernate/Eclipse link : JPA implementation

Spring data JPA : layer on top of jpa
Spring data jpa provides following features on top of jpa
1: no code repository: default implement of crud operations
2: generated queries : it generates jpa queries for us by looky at method name that starts by findBy.....()

To get started with spring data jpa
Add spring data starter jpa and database jdbc driver
Add configuration properties in application.properties file
If our repositories lies in different package other than our main method class. We need to use @EnableJpaRepository annotation

Three repositories provided
1: CrudRepository
2: PagingAndSortingRepository : extends CrudRepository and provides additional methods
3: JpaRepository : add jpa specific methods like flush

Derived Queries (queries automatically generated by spring data jpa from method name)

Method name should start by
FindBy...(), queryBy...(), readBy...()

We can use operator to combining
and, or, not

Comparison operators
Like, containing, ignoringCase, between, greaterThan, lessThan

We can refer related entity by including the name of the referenced entity and the field of referced entity

AuthorRepository extends CrudRepository<Author, PrimaryKeyClass>{
findByBookTitle(String bookTitle);
}

Sorting
OrderByAscFieldName(fieldValue);

Or we can just pass the Sort object in any query to order by

findByFieldName(fieldValue, *Sort sort)

new Sort(Sort.direction.asc, fieldName)


Limit
Top5 or First5
findFirst5ByTitle()

Pagination
Page<Book> getAll(Pagable page)

Use derived query if the parameters are upto two for complex queries and queries requiring more than two parameters use @Query annotation in which we can specify jpql queries or native sql queries

If we use jpql our code will be database agnostic

We can use the Sort and Pagable objects in methods marked with @Query annotation


Binding parameters
1: bind by order
title = ?1 and gener = ?2

2: bind by name * more preferred

title = :title and gener = :gener
@Param("title") String title, @Param("gener") String gener

Modifying queries : queries that update data need to be marked with
@Modifyable


****** Learn : Dto projection, entityGraph, NamedQueries,


Invoke stored procedure
@Procedure()


























